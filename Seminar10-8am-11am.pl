% is, =:= =\=
% < > =< >= 
% + / - * ^ div mod ** // 
% X is 6*7 -> Пресмята се 6*7= 42 -> X = 42

% length(L, N).
length1([], 0).
length1([_|T], N):-length1(T, X), N is X+1.

sum([], 0).
sum([H|T], SumHT):- sum(T, SumT), SumHT is SumT + H.

% nthElement(X, IndX, L).

nthElement(X, 0, [X|_]).
nthElement(X, Counter, [_|T]):- nthElement(X, CounterT, T), Counter is CounterT + 1.
% nthElement(X, Counter, [_|T]):- Counter > 0, Counter1 is Counter - 1, nthElement(X, Counter1, T).

/*
..., -2, -1, 0, 1, 2, ...

0, 1, 2, ...
0, 2, 4, 8, ...
0, 1, 1, 2, 3, 5, 8, 13, ...
Как да генерирате цели числа в даден интервал [A, B], A, B- цели числа?
<0,0>, <0,1>, <1, 0>, ....
?-p(X).
*/

natural(0).
natural(X):-natural(Y), X is Y + 1.

even(0).
even(X):-even(Y), X is Y + 2.

even2(X):-natural(X), X mod 2 =:= 0.

even3(X):-natural(Y), X is Y * 2. 

% ..., -2, -1, 0, 1, 2, ...
% 0, 1, -1, 2, -2, 3, -3, ....
sign(0, 0).
sign(N, M):- N =\= 0, (M is N; M is -N).

sign2(X, Y):-member(Z, [1, -1]), Y is X*Z.

% BAD: naturalPairs(X, Y):-natural(X), natural(Y).
% WORSE: natural5(X):-natural(X), X<5.

int(Z):- natural(N), sign(N, Z).

% 1. Генератор на числата кратни на дадено ест число M

% 2. Краен генератор на цели числа в интервала [A,B], чрез преудовлетворяване, както и като списък с резултатите
% between(A, B, X).
between(A, B, A):- A =< B.
between(A, B, C):- A < B, A1 is A + 1, between(A1, B, C).

% range(A, B, L).
range(A, B, []):- A > B.
range(A, B, [A|R]):- A =< B, A1 is A + 1, range(A1, B, R).

% 3. Генератор на двойки числа
pairs(A, B):- natural(K), between(0, K, A), B is K - A.

% 4. Генератор на K числа със сума S: x_1 + x_2 + ... + x_k = S, x_i >=0
generateKNumbersWithSumS(0, 0, []).
generateKNumbersWithSumS(K, S, [XI|Rest]):- K > 0, K1 is K - 1, between(0, S, XI), S1 is S - XI, 
    generateKNumbersWithSumS(K1, S1, Rest).

% 5. Генератор на всички крайни редици от естествени числа (изброимо много).
generateAllFiniteSequencesOfNaturalNumbers(L):- pairs(K, S), generateKNumbersWithSumS(K, S, L). 

% 6. Числата на Фибоначи
% ?-fib(X). 0 1 1 2 3 5 8 13 21 34

fib(0, 0).
fib(1, 1).
fib(N, X):-N > 1, N1 is N - 1, N2 is N - 2, fib(N1, Y),  fib(N2, Z), X is Y + Z.
fib(X):-natural(N), fib(N, X).

% X Y Z
% X Y X+Y
fibLin(0, 1).
fibLin(Y, Z):-fibLin(X, Y), Z is X+Y.
fibLin(X):-fibLin(X, _).

% a0=a1=a2=1
% a_{n+3} = 2*a_{n+1} - a_n + 0*a_{n+2} + n
% X=a_n Y=a_{n+1} Z=a_{n+2} T=a_{n+3} N
% X Y Z 2*Y - X + N N
% X Y Z N => Y Z T N1
a(1, 1, 1, 0).
a(Y, Z, T, N1):-a(X, Y, Z, N), T is 2*Y - X + N, N1 is N + 1.
a(X):-a(X, _, _, _).


/*   1. Да се напише предикат binary(L), генериращ в L всички двоични дървета, като:
   - [] е двойчно дърво;
   - ако А и В са двойчни дървета, то и [A, B] е двойчно дърво.
[]
[[], []]
[[[], []], []]
...

binary([]).
binary([A, B]):-binary(A), binary(B).
*/
% binary(T, N).
binary([], 0).
binary([LT, RT], K):- K > 0, K1 is K - 1, between(0, K1, N), M is K1 - N, binary(LT, N), binary(RT, M).
binary(T):- natural(N), binary(T, N).

% I.1 Редиците на Фарей, Fn , са редици от двойки естествени числа, които
% се дефинират рекурсивно за n ≥ 1 по следния начин:
% • F1 = [[0, 1], [1, 1]];
% • Fn+1 се получава от Fn , като между всеки два последователни члена
% [a, b] и [c, d] на Fn, за които b+d = n+1, се добавя двойката [a+c, n+1].
% Да се дефинира на пролог едноместен предикат farey(F), който при пре-
% удовлетворяване генерира в F всички редици на Фарей. 

farey(L):- farey(L, _).

farey([[0, 1], [1, 1]], 1).
farey(L1, N1):- farey(L, N), N1 is N + 1, addNewPairs(L, N1, L1).

addNewPairs([H], _, [H]).
addNewPairs([[A, B], [C, D]|T], N1, [[A, B], [APC, N1]|R]):-
    B + D =:= N1,
    APC is A + C,
    addNewPairs([[C, D]|T], N1, R).
addNewPairs([[A, B], [C, D]|T], N1, [[A, B]|R]):-
    B + D =\= N1,
    addNewPairs([[C, D]|T], N1, R).

% 7. split генератор
split([], []).
split([H|T], [A|Rest]):- append(A, B, [H|T]), A \= [], split(B, Rest). 

/*
?- split([1,2,3],L).
L = [[1], [2], [3]] ;
L = [[1], [2, 3]] ;
L = [[1, 2], [3]] ;
L = [[1, 2, 3]] ;
false.
*/

% 5. Да се напише предикат, които "пакетира" елементите в списък L. прим: [1,2,2,1,4,5,5,5] -> [[1], [2,2], [1], [4], [5,5,5]].

pack([A, B|T], [[A]|C]):-A\=B, pack([B|T], C). 
pack([A, A|T], [[A|C1]|C]):-pack([A|T], [C1|C]).
pack([], []).
pack([A], [[A]]).

/*
   2. Да се дефинира предикат p(L, R), който генерира в R всички списъци с елемнти от L.
   3. Да се напише предикат p(N), генериращ ввсички числа от вида ai + bj:
   |a0 = 1						|b0 = 7
   |aN = 3*a(N - 1) + n 		|bN = 3b(N - 1) + n^2 - 1
   4. Да се напише предикат генериращ всички числа между 0 и 1000, които са от следния вид 8*(n+11)^5 * (19 + k)^2
*/

/*
07.07.2014 г
Зад. 1. Да се дефинира на Пролог предикат p(A), кой-
то при преудовлетворяване генерира в A всички крайни
строго монотонно растящи аритметични прогресии от ес-
тествени числа.

	Можем да подходим по два начина:

 Начин 1 директно конструираме решението
 Начин 2 генерираме всички списъци и взимаме сато тези, които ни вършат работа, т.е. са 
 аритметични прогресии.
*/

arithmetic(L):- generateAllFiniteSequencesOfNaturalNumbers(L), condition(L).

condition([]).
condition([_]).
condition([A, B]):- A < B.
condition(L):- length(L, N), N > 2, not(( append(_, [AN, AN1, AN2|_], L), not(( AN < AN1, AN1 =:= (AN + AN2) / 2)) )).




/*
Зад. 1. Диаметър на списък наричаме разликата между броя срещания на най-често срещан
елемент на списъка и броя срещания на най-рядко срещан елемент на списъка. Да се дефинира
на Пролог едноместен предикат p, който по даден списък от списъци L разпознава дали:
всички елементи на L имат един и същ диаметър.
*/

/*Зад. 2. Списък от три числа [X,Y,R] ще интерпрети-
раме като окръжност с център hX,Y i и радиус R. 
a) Да се дефинира генератор circles1(X,Y,R,Z,T,S), който по
дадена окръжност [X,Y,R] при преудовлетворяване ге-
нерира в Z, T и S окръжностите, които съдържат ок-
ръжността [X,Y,R].
b) Да се дефинира генератор circles2(X,Y,R,Z,T,S), който по
дадена окръжност [X,Y,R] при преудовлетворяване ге-
нерира в Z, T и S окръжностите, които се съдържат ок-
ръжността [X,Y,R].
*/

/*
	24 януари 2018 изпита
	Фенски списък е краен списък, всеки елемент на който е някоя от буквите 1, 2 или е
	фенски списък, като никои два съседни елемента не са еднакви букви.
	Да се дефинира на Пролог едноместен предикат p(X), който при преудовлетворяване
	генерира в X всички фенски списъци, които се записват на Пролог с краен брой “[”
	*/

/*
	1. Реализирайте алгоритъм stree(V, E, ST), генериращ в ST покриващото дърво на графа G(V, E)
	2. Септемврийска сесия 2013 г.
	Зад. 1. Нека G е неориентиран граф. Множеството от вър-
	ховете на G е представено със списък V от върховете, всяко
	ребро v е представено с двуелементен списък на краища-
	та му, а множеството от ребрата на G е представено със
	списък E от ребрата.
	Да се дефинира на Пролог предикат
	а) con(V, E), който разпознава дали представеният с V и
	E граф е свързан.
	б) crit(V, E, X), който по дадени V и E на свързан граф ге-
	нерира в X списък на всички върхове, чието отстраняване
	води до граф, който не е свързан. (3 + 3 точки)
	3. 12.04.2014 г.
	Зад. 1. a) Да се дефинира на Пролог предикат
	p(X,A,B), който по даден списък от двойки X =
	[[a1, b1],[a2 ,b2 ],...,[an , bn ]] проверява дали шахматният
	кон може да се придвижи с един ход от поле с коорди-
	нати [A,B] на поле, чиито координати не са елемент на
	списъка X.
	б) Да се дефинира предикат q(X), който проверява да-
	ли шахматният кон може да се придвижи от поле с
	координати [1,1] на поле [8,8], без да преминава през
	полета, чиито координати са елемент на списъка X =
	[[a1, b1],[a2 ,b2 ],...,[an , bn ]].
	Забележка. Шахматната дъска е с размер 8 × 8.
*/
